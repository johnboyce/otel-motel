input {
  # TCP input for receiving logs
  tcp {
    port => 5044
    codec => json_lines
  }
  
  # HTTP input for receiving logs
  http {
    port => 8080
    codec => json
  }
}

filter {
  # Parse JSON logs if they're in string format
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      target => "parsed"
    }
    
    # Extract fields from parsed JSON
    if [parsed] {
      mutate {
        rename => {
          "[parsed][timestamp]" => "@timestamp"
          "[parsed][level]" => "log.level"
          "[parsed][logger_name]" => "log.logger"
          "[parsed][message]" => "message"
          "[parsed][thread_name]" => "process.thread.name"
        }
      }
    }
  }
  
  # Add ECS fields
  mutate {
    add_field => {
      "[ecs][version]" => "8.0.0"
      "[service][name]" => "otel-motel"
      "[service][environment]" => "dev"
    }
  }
  
  # Convert log level to lowercase for ECS compliance
  if [log.level] {
    mutate {
      lowercase => ["log.level"]
    }
  }
  
  # Parse timestamp if it's a string
  if [@timestamp] =~ /^\d{4}-\d{2}-\d{2}/ {
    date {
      match => ["@timestamp", "ISO8601"]
      target => "@timestamp"
    }
  }
}

output {
  # Output to Elasticsearch with ECS mapping
  elasticsearch {
    hosts => ["http://elasticsearch:9200"]
    index => "otel-motel-logs-%{+YYYY.MM.dd}"
    template_name => "otel-motel-logs"
    template_overwrite => true
    document_type => "_doc"
  }
  
  # Debug output (can be disabled in production)
  stdout {
    codec => rubydebug
  }
}
